{"_id":{"$oid":"5dd2f350c15d8cb73d1119bc"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119bd"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119be"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119bf"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c0"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c1"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c2"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c3"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c4"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd2f350c15d8cb73d1119c5"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24a7"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24a8"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24a9"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24aa"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24ab"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24ac"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24ad"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24ae"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24af"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd300c6f1aaa6883a0a24b0"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b1"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b2"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b3"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b4"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b5"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b6"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b7"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b8"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24b9"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd30179f1aaa6883a0a24ba"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24bb"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24bc"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24bd"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24be"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24bf"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24c0"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24c1"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24c2"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24c3"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd301f7f1aaa6883a0a24c4"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24c5"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24c6"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24c7"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24c8"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24c9"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24ca"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5dd30232f1aaa6883a0a24cb"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24cc"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24cd"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24ce"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24cf"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d0"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d1"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d2"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d3"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d4"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd302c6f1aaa6883a0a24d5"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd40a80715f5ae58731c307"},"id":"http://arxiv.org/abs/1307.7494v1","summary":"We present ReAct!, an interactive tool for high-level reasoning for cognitive\nrobotic applications. ReAct! enables robotic researchers to describe robots'\nactions and change in dynamic domains, without having to know about the\nsyntactic and semantic details of the underlying formalism in advance, and\nsolve planning problems using state-of-the-art automated reasoners, without\nhaving to learn about their input/output language or usage. In particular,\nReAct! can be used to represent sophisticated dynamic domains that feature\nconcurrency, indirect effects of actions, and state/transition constraints. It\nallows for embedding externally defined calculations (e.g., checking for\ncollision-free continuous trajectories) into representations of hybrid domains\nthat require a tight integration of (discrete) high-level reasoning with\n(continuous) geometric reasoning. ReAct! also enables users to solve planning\nproblems that involve complex goals. Such variety of utilities are useful for\nrobotic researchers to work on interesting and challenging domains, ranging\nfrom service robotics to cognitive factories. ReAct! provides sample\nformalizations of some action domains (e.g., multi-agent path planning, Tower\nof Hanoi), as well as dynamic simulations of plans computed by a\nstate-of-the-art automated reasoner (e.g., a SAT solver or an ASP solver).","authors":["Zeynep Dogmus","Esra Erdem","Volkan Patoglu"],"author":"Volkan Patoglu","pdf_url":"http://arxiv.org/pdf/1307.7494v1","title":"ReAct! An Interactive Tool for Hybrid Planning in Robotics","arxiv_comment":null}
{"_id":{"$oid":"5dd40a80715f5ae58731c308"},"id":"http://arxiv.org/abs/1707.05805v2","summary":"The Volvo burner features the canonical configuration of a bluff-body\nstabilized premixed flame. This configuration was studied experimentally under\nthe Volvo Flygmotor AB program. Two cases are considered in this study: a\nnon-reacting case with an inlet flow speed of 16.6 m/s and a reacting case with\nequilibrium ratio of 0.65 and inflow speed of 17.3 m/s. The characteristic\nvortex shedding in the wake behind the bluff body is present in the\nnon-reacting case, while two oscillation modes are intermittently present in\nthe reacting case. A series of large-eddy simulations are performed on this\nconfiguration using two solvers, one using a high-resolution finite-volume (FV)\nscheme and the other featuring a high-order discontinuous-Galerkin (DG)\ndiscretization. The FV calculations are conducted on hexahedral meshes with\nthree different resolution (4mm, 2mm, and 1mm). The DG calculations are\nperformed using two different polynomial orders on the same tetrahedral mesh.\nFor the non-reacting cases, good agreement with respect to the experimental\ndata is achieved by both solvers at high numerical resolution. The reacting\ncases are calculated using a two-step global mechanism in combination with the\nthickened-flame model. Reasonable agreement with experiments is obtained by\nboth solvers at higher resolution. Models for combustion-turbulence interaction\nare necessary for the reacting case as it contains the length scale of the\nflame, which is smaller than the grid resolution in all calculations. The\nimpact of such models on the flame stability and flow/flame dynamics is the\nsubject of future research.","authors":["Hao Wu","Peter C. Ma","Yu Lv","Matthias Ihme"],"author":"Matthias Ihme","pdf_url":"http://arxiv.org/pdf/1707.05805v2","title":"MVP-Workshop Contribution: Modeling of Volvo Bluff Flame Experiment and\n  Comparison of Finite-Volume and Discontinuous-Galerkin Schemes","arxiv_comment":null}
{"_id":{"$oid":"5dd40a80715f5ae58731c309"},"id":"http://arxiv.org/abs/1907.07846v1","summary":"The impact of chemical reactions on the robustness and accuracy of\nprojection-based Reduced-Order Models (ROMs) of fluid flows is investigated.\nBoth Galerkin and Least-Squares Petrov Galerkin ROMs are shown to be less\nrobust in reacting flows as compared to non-reacting flows. In particular,\nreacting flow ROMs show a strong sensitivity to \\st{the} resolution and are\noften unstable. To identify the main underlying causes, a representative\nproblem that contains the essential physics encountered in typical combustion\ndynamics problems is chosen. Comparisons with non-reacting solutions are used\nto assess the impact of reactions. Investigations are focused on three\npotential areas of significance: 1) preservation of conservation laws; 2) loss\nof dissipation; and 3) existence of unphysical local phenomena. Results\nindicate that conservation is relatively well-controlled and the global\ndissipation in the ROMs is actually larger than that in the underlying CFD\nsolutions. Spurious local phenomena are, however, highly deleterious.\nSpecifically, the steep temperature gradients that characterize combustion can\nlead to oscillations in local temperatures even in the absence of reactions.\nRepresentative calculations with physics-based temperature constraints verify\nthat eliminating such excursions results in considerable improvement in both\nstability and future-state prediction capability.","authors":["Cheng Huang","Karthik Duraisamy","Charles L. Merkle"],"author":"Charles L. Merkle","pdf_url":"http://arxiv.org/pdf/1907.07846v1","title":"Investigations and Improvement of Robustness of Reduced-Order Models of\n  Reacting Flow","arxiv_comment":null}
{"_id":{"$oid":"5dd40a80715f5ae58731c30a"},"id":"http://arxiv.org/abs/0801.2708v1","summary":"We consider a simple-model population, whose individuals react with a certain\ndelay to temporal variations of their habitat. We investigate the impact of\nsuch a delayed-answer on the survival chances of the population, both in a\nperiodically changing environment, and in the case of an abrupt change of it.\nIt is found that for population with low degree of mutation-induced\nvariability, being \"slow-reacting\" decreases the extinction risk face to\nenvironmental changes. On the contrary, for populations with high mutation\namplitude, the delayed reaction reduces the survival chances.","authors":["Ioana Bena","Michel Droz","Janusz Szwabinski","Andrzej Pekalski"],"author":"Andrzej Pekalski","pdf_url":"http://arxiv.org/pdf/0801.2708v1","title":"How bad is to be slow-reacting ? On the effect of the delay in response\n  to a changing environment on a population's survival","arxiv_comment":"7 pages, 4 figures"}
{"_id":{"$oid":"5dd40a80715f5ae58731c30b"},"id":"http://arxiv.org/abs/1211.2661v1","summary":"A feedback stabilization scheme to stabilize a classical reacting Hamiltonian\nsystem is proposed. It is based on transforming a saddle-type equilibrium to an\nasymptotically stable one, and is given in a simple and algorithmic way. The\nquestion of destabilization of a stable system to make a reacting system is\nalso addressed. The theory is illustrated with the examples of a model\nHamiltonian of the form kinetic plus potential, and the hydrogen atom in\ncrossed and magnetic fields.","authors":["√únver √áift√ßi"],"author":"√únver √áift√ßi","pdf_url":"http://arxiv.org/pdf/1211.2661v1","title":"Stabilization of reacting systems","arxiv_comment":"13 pages, 5 figures"}
{"_id":{"$oid":"5dd40a80715f5ae58731c30c"},"id":"http://arxiv.org/abs/1512.08765v1","summary":"We consider a reaction-diffusion system where some components react and\ndiffuse on the boundary of a region, while other components diffuse in the\ninterior and react with those on the boundary through mass transport. We\nestablish criteria guaranteeing that solutions are uniformly bounded in time.","authors":["Vandana Sharma","Jeff Morgan"],"author":"Jeff Morgan","pdf_url":"http://arxiv.org/pdf/1512.08765v1","title":"Uniform Bounds for Solutions to Volume-Surface Reaction Diffusion\n  Systems","arxiv_comment":"15 pages. arXiv admin note: text overlap with arXiv:1504.00323"}
{"_id":{"$oid":"5dd40a80715f5ae58731c30d"},"id":"http://arxiv.org/abs/1801.03046v1","summary":"In this work, methods for the evaluation of LES-quality and LES-accuracy are\npresented, which include the Lyapunov exponent for the analysis of short-time\npredictability of LES-calculation and the Wasserstein metric for the\nquantitative assessment of simulation results. Both methods are derived and\nevaluated in application to the Volvo test case. Both the non-reacting and\nreacting cases are calculated. For the non- reacting cases, good agreement with\nthe experimental data is achieved by solvers at high numerical resolution. The\nreacting cases are more challenging due to the small length scale of the flame\nand the suppression of sinuous mode of absolute instability by the density\nratio. The analysis of the turbulent simulation data using the concept of the\nLyapunov exponent and the Wasserstein metric provides a more quantitative\napproach to assess the mesh dependency of the simulation results. The\nconvergence of the Lyapunov exponent is shown to be a more sensitive and\nstronger indication of mesh-independence. Though grid convergence for the\nreacting cases cannot be reached with the chosen resolutions, the Lyapunov\nexponents and the Wasserstein metric are shown to be capable of identifying\nquantity-specific sensitivities with respect to the numerical resolution, while\nrequiring significantly less computational resources than acquiring profiles of\nconventional turbulent statistics.","authors":["Hao Wu","Peter C. Ma","Yu Lv","Matthias Ihme"],"author":"Matthias Ihme","pdf_url":"http://arxiv.org/pdf/1801.03046v1","title":"Lyapunov exponent and Wasserstein metric as validation tools for\n  assessing short-time dynamics and quantitative model evaluation of large-eddy\n  simulation","arxiv_comment":"2018 AIAA Aerospace Sciences Meeting, Kissimmee, FL"}
{"_id":{"$oid":"5dd40a80715f5ae58731c30e"},"id":"http://arxiv.org/abs/astro-ph/9702070v1","summary":"It is shown that two reacting cosmological fluids, each of them perfect on\nits own, which exchange energy and momentum without preserving particle\nnumbers, give rise to an entropy producing `reactive' bulk stress of the system\nas a whole, as soon as the detailed balance between decay and inverse decay\nprocesses is perturbed. This demonstrates explicitly that particle generation\nis dynamically equivalent to an effective bulk pressure. We derive a\nsemiquantitative formula for the corresponding new kinetic coefficient and\nevaluate the latter for the out-of-equilibrium decay of heavy, nonrelativistic\nparticles into radiation. It turns out that the associated reactive bulk\nviscosity may be more than one order of magnitude larger than the conventional\nbulk viscosity, calculated, e.g., in radiative hydrodynamics.","authors":["Winfried Zimdahl"],"author":"Winfried Zimdahl","pdf_url":"http://arxiv.org/pdf/astro-ph/9702070v1","title":"Reacting fluids in the expanding Universe: A new mechanism for entropy\n  production","arxiv_comment":"13 pages, Revtex, submitted to MNRAS"}
{"_id":{"$oid":"5dd40a80715f5ae58731c30f"},"id":"http://arxiv.org/abs/chao-dyn/9906029v1","summary":"We study the spatial patterns formed by interacting populations or reacting\nchemicals under the influence of chaotic flows. In particular, we have\nconsidered a three-component model of plankton dynamics advected by a\nmeandering jet. We report general results, stressing the existence of a\nsmooth-filamental transition in the concentration patterns depending on the\nrelative strength of the stirring by the chaotic flow and the relaxation\nproperties of planktonic dynamical system. Patterns obtained in open and closed\nflows are compared.","authors":["Cristobal Lopez","Zoltan Neufeld","Emilio Hernandez-Garcia","Peter H. Haynes"],"author":"Peter H. Haynes","pdf_url":"http://arxiv.org/pdf/chao-dyn/9906029v1","title":"Chaotic advection of reacting substances: Plankton dynamics on a\n  meandering jet","arxiv_comment":"5 pages, 3 figues, latex compiled with modegs.cls"}
{"_id":{"$oid":"5dd40a80715f5ae58731c310"},"id":"http://arxiv.org/abs/math/0410467v1","summary":"We present a computer-assisted approach to locating approximate coarse\noptimal switching policies between stationary states of chemically reacting\nsystems described by microscopic/stochastic evolution rules. The ``coarse\ntime-stepper\" constitutes a bridge between the underlying kinetic Monte Carlo\nsimulation and traditional, continuum numerical optimization techniques\nformulated in discrete time. The approach is illustrated through two simple\ncatalytic surface reaction models, implemented through kinetic Monte Carlo: NO\nreduction on Pt, and CO oxidation on Pt. The objective sought in both cases is\nto switch between two coexisting stable stationary states by minimal\nmanipulation of a macroscopic system parameter.","authors":["Antonios Armaou","Ioannis G. Kevrekidis"],"author":"Ioannis G. Kevrekidis","pdf_url":"http://arxiv.org/pdf/math/0410467v1","title":"Equation-free optimal switching policies for bistable reacting systems\n  using coarse time-steppers","arxiv_comment":"31 pages, 6 tables, 11 figures"}
{"_id":{"$oid":"5dd40abe715f5ae58731c311"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5dd40abe715f5ae58731c312"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5dd40abe715f5ae58731c313"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5dd40abe715f5ae58731c314"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5dd40abe715f5ae58731c315"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5dd40abe715f5ae58731c316"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5dd40abe715f5ae58731c317"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5dd40ded715f5ae58731c318"},"id":"http://arxiv.org/abs/astro-ph/0607350v1","summary":"The idea of a unified model for all astrophysical jets has been considered\nfor quite some time. We present here a few scaling laws relevant to all type of\nastrophysical jets, analogous to those of \\citet{sams96} which are widely used\nfor astrophysical black holes. We use Buckingham's $ \\Pi $ theorem of\ndimensional analysis to obtain a family of dimensional relations among the\nphysical quantities associated to astrophysical jets.","authors":["M. Huarte-Espinosa","S. Mendoza"],"author":"S. Mendoza","pdf_url":"http://arxiv.org/pdf/astro-ph/0607350v1","title":"Simple scaling laws for astrophysical jets","arxiv_comment":"LaTeX, 9 pages"}
{"_id":{"$oid":"5dd40ded715f5ae58731c319"},"id":"http://arxiv.org/abs/0903.4884v1","summary":"I discuss the scientific rationale and opportunities in the study of high\nenergy particle accelerators away from the Earth; mostly, those outside the\nSolar System. I also briefly outline the features to be desired in telescopes\nused to probe accelerators studied by remote sensing.","authors":["Jonathan Arons"],"author":"Jonathan Arons","pdf_url":"http://arxiv.org/pdf/0903.4884v1","title":"Cosmic Accelerators","arxiv_comment":"A White Paper submitted to the Astro 2010 Decadal Survey"}
{"_id":{"$oid":"5dd40ded715f5ae58731c31a"},"id":"http://arxiv.org/abs/nucl-th/0007070v1","summary":"This is an overview over the prediction of astrophysical reaction rates in\nthe statistical model, with special emphasis on the parametrization of optical\nalpha+nucleus potentials.","authors":["T. Rauscher"],"author":"T. Rauscher","pdf_url":"http://arxiv.org/pdf/nucl-th/0007070v1","title":"Prediction of nuclear reaction rates for astrophysics","arxiv_comment":"3 pages"}
{"_id":{"$oid":"5dd40ded715f5ae58731c31b"},"id":"http://arxiv.org/abs/nucl-th/0609006v1","summary":"I review progress that has been made in nuclear astrophysics over the past\nfew years and summarize some of the questions that remain. Topics selected\ninclude solar neutrinos, supernovae (the explosion and associated\nnucleosynthesis), laboratory astrophysics, and neutron star structure.","authors":["W. C. Haxton"],"author":"W. C. Haxton","pdf_url":"http://arxiv.org/pdf/nucl-th/0609006v1","title":"Nuclear Astrophysics: CIPANP 2006","arxiv_comment":"11 pages; talk presented CIPANP 2006"}
{"_id":{"$oid":"5dd40ded715f5ae58731c31c"},"id":"http://arxiv.org/abs/1009.1542v1","summary":"I present both a history of radioactivity in astrophysics and an introduction\nto the major applications of radioactive abundances to astronomy.","authors":["Donald Clayton"],"author":"Donald Clayton","pdf_url":"http://arxiv.org/pdf/1009.1542v1","title":"The Role of Radioactivities in Astrophysics","arxiv_comment":null}
{"_id":{"$oid":"5dd40ded715f5ae58731c31d"},"id":"http://arxiv.org/abs/0704.0281v1","summary":"An critical overview of the current state of research in turbulence in\nastrophysical disks.","authors":["Denis Richard"],"author":"Denis Richard","pdf_url":"http://arxiv.org/pdf/0704.0281v1","title":"The Source of Turbulence in Astrophysical Disks: An Ill-posed Problem.","arxiv_comment":"UCSC-NASA Ames Research Center Workshop on Stellar and Planets\n  Formation March 29, 2007"}
{"_id":{"$oid":"5dd40ded715f5ae58731c31e"},"id":"http://arxiv.org/abs/0705.2972v1","summary":"A summary of the session on Particle Astrophysics at the Rencontre de\nVietnam, 2006.","authors":["Hinrich Meyer"],"author":"Hinrich Meyer","pdf_url":"http://arxiv.org/pdf/0705.2972v1","title":"Summary Talk: Challenges in Particle Astrophysics","arxiv_comment":"6 pages, Summary talk given at 'Rencontre de Vietnam, Hanoi, 2006"}
{"_id":{"$oid":"5dd40ded715f5ae58731c31f"},"id":"http://arxiv.org/abs/0706.1767v1","summary":"We review the current status, and some open issues, of VHE astrophysics.","authors":["Massimo Persic","Alessandro De Angelis"],"author":"Alessandro De Angelis","pdf_url":"http://arxiv.org/pdf/0706.1767v1","title":"VHE astrophysics: recent developments","arxiv_comment":"8 pages, invited review, Mem.S.A.It., in press"}
{"_id":{"$oid":"5dd40ded715f5ae58731c320"},"id":"http://arxiv.org/abs/1402.7302v1","summary":"Outlook talk presented at the 10th International Symposium on Cosmology and\nParticle Astrophysics (CosPA2013)","authors":["Francis Halzen"],"author":"Francis Halzen","pdf_url":"http://arxiv.org/pdf/1402.7302v1","title":"CosPA2013: Outlook","arxiv_comment":"to appear in the proceedings of The 10th International Symposium on\n  Cosmology and Particle Astrophysics (CosPA2013)"}
{"_id":{"$oid":"5dd40ded715f5ae58731c321"},"id":"http://arxiv.org/abs/1701.06059v1","summary":"The parallel session on \"Relativistic and Particle Astrophysics\" was held on\n14th December 2015. Here a short summary of each presentation of this parallel\nsession is given.","authors":["Jakub Ripa"],"author":"Jakub Ripa","pdf_url":"http://arxiv.org/pdf/1701.06059v1","title":"Summary of Parallel Session: \"Relativistic and Particle Astrophysics\"","arxiv_comment":"6 pages"}
{"_id":{"$oid":"5dd41069715f5ae58731c322"},"id":"http://arxiv.org/abs/1108.5460v1","summary":"The field of information extraction from the Web emerged with the growth of\nthe Web and the multiplication of online data sources. This paper is an\nanalysis of information extraction methods. It presents a service oriented\napproach for web information extraction considering both web data management\nand extraction services. Then we propose an SOA based architecture to enhance\nflexibility and on-the-fly modification of web extraction services. An\nimplementation of the proposed architecture is proposed on the middleware level\nof Java Enterprise Edition (JEE) servers.","authors":["Zahi Jarir","Mohamed Quafafou","Mahammed Erradi"],"author":"Mahammed Erradi","pdf_url":"http://arxiv.org/pdf/1108.5460v1","title":"Personalized Web Services for Web Information Extraction","arxiv_comment":null}
{"_id":{"$oid":"5dd41069715f5ae58731c323"},"id":"http://arxiv.org/abs/1111.5518v1","summary":"Peer-to-peer (P2P) Data-sharing systems now generate a significant portion of\ninternet traffic. P2P systems have emerged as a popular way to share huge\nvolumes of data. Requirements for widely distributed information systems\nsupporting virtual organizations have given rise to a new category of P2P\nsystems called schema- based. In such systems each peer is a database\nmanagement system in itself, ex-posing its own schema. A fundamental problem\nthat confronts peer-to-peer applications is the efficient location of the node\nthat stores a desired data item. In such settings, the main objective is the\nefficient search across peer databases by processing each incoming query\nwithout overly consuming bandwidth. The usability of these systems depends on\neffective techniques to find and retrieve data; however, efficient and\neffective routing of content- based queries is an emerging problem in P2P\nnetworks. In this paper, we propose an architecture, based on super-peers, and\nwe focus on query routing. Our approach considers that super-Peers having\nsimilar interests are grouped together for an efficient query routing method.\nIn such groups, called Knowledge-Super-Peers (KSP), super-peers submit queries\nthat are often processed by members of this group.","authors":["Anis Ismail","Mohamed Quafafou","Gilles Nachouki","Mohammad Hajjar"],"author":"Mohammad Hajjar","pdf_url":"http://arxiv.org/pdf/1111.5518v1","title":"Efficient Super-Peer-Based Queries Routing: Simulation and Evaluation","arxiv_comment":"Journal of Emerging Technologies in Web Intelligence, Vol 3, No 3\n  (2011), 206-216, Aug 2011"}
{"_id":{"$oid":"5dd41069715f5ae58731c324"},"id":"http://arxiv.org/abs/0902.4042v1","summary":"The objectives of this research work which is intimately related to pattern\ndiscovery and management are threefold: (i) handle the problem of pattern\nmanipulation by defining operations on patterns, (ii) study the problem of\nenriching and updating a pattern set (e.g., concepts, rules) when changes occur\nin the user's needs and the input data (e.g., object/attribute insertion or\nelimination, taxonomy utilization), and (iii) approximate a \"presumed\" concept\nusing a related pattern space so that patterns can augment data with knowledge.\nTo conduct our work, we use formal concept analysis (FCA) as a framework for\npattern discovery and management and we take a joint database-FCA perspective\nby defining operators similar in spirit to relational algebra operators,\ninvestigating approximation in concept lattices and exploiting existing work\nrelated to operations on contexts and lattices to formalize such operators.","authors":["Rokia Missaoui","Leonard Kwuida","Mohamed Quafafou","Jean Vaillancourt"],"author":"Jean Vaillancourt","pdf_url":"http://arxiv.org/pdf/0902.4042v1","title":"Algebraic operators for querying pattern bases","arxiv_comment":null}
{"_id":{"$oid":"5dd41069715f5ae58731c325"},"id":"http://arxiv.org/abs/1304.3268v1","summary":"This paper shows that the problem of web services representation is crucial\nand analyzes the various factors that influence on it. It presents the\ntraditional representation of web services considering traditional textual\ndescriptions based on the information contained in WSDL files. Unfortunately,\ntextual web services descriptions are dirty and need significant cleaning to\nkeep only useful information. To deal with this problem, we introduce rules\nbased text tagging method, which allows filtering web service description to\nkeep only significant information. A new representation based on such filtered\ndata is then introduced. Many web services have empty descriptions. Also, we\nconsider web services representations based on the WSDL file structure (types,\nattributes, etc.). Alternatively, we introduce a new representation called\nsymbolic reputation, which is computed from relationships between web services.\nThe impact of the use of these representations on web service discovery and\nrecommendation is studied and discussed in the experimentation using real world\nweb services.","authors":["Mustapha Aznag","Mohamed Quafafou","Nicolas Durand","Zahi Jarir"],"author":"Zahi Jarir","pdf_url":"http://arxiv.org/pdf/1304.3268v1","title":"Web Services Discovery and Recommendation Based on Information\n  Extraction and Symbolic Reputation","arxiv_comment":null}
{"_id":{"$oid":"5dd41069715f5ae58731c326"},"id":"http://arxiv.org/abs/1109.5679v1","summary":"Peer-to-peer (P2P) computing is currently attracting enormous attention. In\nP2P systems a very large number of autonomous computing nodes (the peers) pool\ntogether their resources and rely on each other for data and services.\nPeer-to-peer (P2P) Data-sharing systems now generate a significant portion of\nInternet traffic. Examples include P2P systems for network storage, web\ncaching, searching and indexing of relevant documents and distributed\nnetwork-threat analysis. Requirements for widely distributed information\nsystems supporting virtual organizations have given rise to a new category of\nP2P systems called schema-based. In such systems each peer exposes its own\nschema and the main objective is the efficient search across the P2P network by\nprocessing each incoming query without overly consuming bandwidth. The\nusability of these systems depends on effective techniques to find and retrieve\ndata; however, efficient and effective routing of content-based queries is a\nchallenging problem in P2P networks. This work was attended as an attempt to\nmotivate the use of mining algorithms and hypergraphs context to develop two\ndifferent methods that improve significantly the efficiency of P2P\ncommunications. The proposed query routing methods direct the query to a set of\nrelevant peers in such way as to avoid network traffic and bandwidth\nconsumption. We compare the performance of the two proposed methods with the\nbaseline one and our experimental results prove that our proposed methods\ngenerate impressive levels of performance and scalability.","authors":["Anis Ismail","Mohamed Quafafou","Nicolas Durand","Gilles Nachouki","Mohammad Hajjar"],"author":"Mohammad Hajjar","pdf_url":"http://arxiv.org/pdf/1109.5679v1","title":"Queries mining for efficient routing in P2P communities","arxiv_comment":"20 pages, 9 figures. arXiv admin note: substantial text overlap with\n  arXiv:1108.1378"}
{"_id":{"$oid":"5dd41069715f5ae58731c327"},"id":"http://arxiv.org/abs/1108.1378v1","summary":"Peer-to-peer (P2P) Data-sharing systems now generate a significant portion of\nInternet traffic. P2P systems have emerged as an accepted way to share enormous\nvolumes of data. Needs for widely distributed information systems supporting\nvirtual organizations have given rise to a new category of P2P systems called\nschema-based. In such systems each peer is a database management system in\nitself, ex-posing its own schema. In such a setting, the main objective is the\nefficient search across peer databases by processing each incoming query\nwithout overly consuming bandwidth. The usability of these systems depends on\nsuccessful techniques to find and retrieve data; however, efficient and\neffective routing of content-based queries is an emerging problem in P2P\nnetworks. This work was attended as an attempt to motivate the use of mining\nalgorithms in the P2P context may improve the significantly the efficiency of\nsuch methods. Our proposed method based respectively on combination of\nclustering with hypergraphs. We use ECCLAT to build approximate clustering and\ndiscovering meaningful clusters with slight overlapping. We use an algorithm\nMTMINER to extract all minimal transversals of a hypergraph (clusters) for\nquery routing. The set of clusters improves the robustness in queries routing\nmechanism and scalability in P2P Network. We compare the performance of our\nmethod with the baseline one considering the queries routing problem. Our\nexperimental results prove that our proposed methods generate impressive levels\nof performance and scalability with with respect to important criteria such as\nresponse time, precision and recall.","authors":["Anis Ismail","Mohamed Quafafou","Nicolas Durand","Mohammad Hajjar"],"author":"Mohammad Hajjar","pdf_url":"http://arxiv.org/pdf/1108.1378v1","title":"An Efficient Architecture for Information Retrieval in P2P Context Using\n  Hypergraph","arxiv_comment":"2o pages, 8 figures"}
{"_id":{"$oid":"5dd410fb715f5ae58731c328"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd410fb715f5ae58731c329"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd410fb715f5ae58731c32a"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd410fb715f5ae58731c32b"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd410fb715f5ae58731c32c"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd410fb715f5ae58731c32d"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd410fb715f5ae58731c32e"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd410fb715f5ae58731c32f"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd410fb715f5ae58731c330"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd410fb715f5ae58731c331"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd4122c715f5ae58731c332"},"id":"http://arxiv.org/abs/1705.05476v1","summary":"JavaScript is one of the most popular programming languages on the web.\nDespite the language popularity and the increasing size of JavaScript systems,\nthere is a limited number of visualization tools that can be used by developers\nto comprehend, maintain, and evolve JavaScript software. In this paper, we\nintroduce JSCity, an implementation in JavaScript of the well-known Code City\nsoftware visualization metaphor. JSCity relies on JavaScript features and\nlibraries to show \"software cities\" in standard web browsers, without requiring\ncomplex installation procedures. We also report our experience on producing\nvisualizations for 40 popular JavaScript systems using JScity.","authors":["Marcos Viana","Andre Hora","Marco Tulio Valente"],"author":"Marco Tulio Valente","pdf_url":"http://arxiv.org/pdf/1705.05476v1","title":"CodeCity for (and by) JavaScript","arxiv_comment":null}
{"_id":{"$oid":"5dd4122c715f5ae58731c333"},"id":"http://arxiv.org/abs/0912.2861v1","summary":"The JSC language is a superset of JavaScript designed to ease the development\nof large web applications. This language extends JavaScripts own object system\nby isolating code in a class declaration, simplifying multiple inheritance and\nusing method implementation agreements.","authors":["Artur Ventura"],"author":"Artur Ventura","pdf_url":"http://arxiv.org/pdf/0912.2861v1","title":"JSC : A JavaScript Object System","arxiv_comment":"7 pages"}
{"_id":{"$oid":"5dd4122c715f5ae58731c334"},"id":"http://arxiv.org/abs/1812.03939v2","summary":"Today, third-party JavaScript resources are indispensable part of the web\nplatform. More than 88% of world's top websites include at least one JavaScript\nresource from a remote host. However, there is a great security risk behind\nusing a third-party JavaScript resource, if an attacker can infect one of these\nremote JavaScript resources all websites those have included the script would\nbe at risk. In this paper, we present JSSignature, an entirely at the\nclient-side pure JavaScript framework in order to validate third-party\nJavaScript resources using digital signature. Therefore, all included\nJavaScript resources are checked against the integrity, authentication and\nnon-repudiation risks before the execution. In contrary to existing methods,\nJSSignature protects web pages regardless of third-party resource infection\nnature while it does not set any restrictions on trusted JavaScript providers.\nThis approach has an acceptable one-time performance overhead and is an easily\ndeployable add-in. We have validated the proposed solution by applying tests on\nan implemented version\\footnote{The source-code, resources and the working demo\nare available at JSSignature website.","authors":["Kousha Nakhaei","Ebrahim Ansari","Fateme Ansari"],"author":"Fateme Ansari","pdf_url":"http://arxiv.org/pdf/1812.03939v2","title":"JSSignature: Eliminating Third-Party-Hosted JavaScript Infection Threats\n  Using Digital Signatures","arxiv_comment":"18 pages, 2 figures, Submitted to CiDaS 2019"}
{"_id":{"$oid":"5dd4122c715f5ae58731c335"},"id":"http://arxiv.org/abs/1401.4339v2","summary":"Websites today routinely combine JavaScript from multiple sources, both\ntrusted and untrusted. Hence, JavaScript security is of paramount importance. A\nspecific interesting problem is information flow control (IFC) for JavaScript.\nIn this paper, we develop, formalize and implement a dynamic IFC mechanism for\nthe JavaScript engine of a production Web browser (specifically, Safari's\nWebKit engine). Our IFC mechanism works at the level of JavaScript bytecode and\nhence leverages years of industrial effort on optimizing both the source to\nbytecode compiler and the bytecode interpreter. We track both explicit and\nimplicit flows and observe only moderate overhead. Working with bytecode\nresults in new challenges including the extensive use of unstructured control\nflow in bytecode (which complicates lowering of program context taints),\nunstructured exceptions (which complicate the matter further) and the need to\nmake IFC analysis permissive. We explain how we address these challenges,\nformally model the JavaScript bytecode semantics and our instrumentation, prove\nthe standard property of termination-insensitive non-interference, and present\nexperimental results on an optimized prototype.","authors":["Abhishek Bichhawat","Vineet Rajani","Deepak Garg","Christian Hammer"],"author":"Christian Hammer","pdf_url":"http://arxiv.org/pdf/1401.4339v2","title":"Information Flow Control in WebKit's JavaScript Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd4122c715f5ae58731c336"},"id":"http://arxiv.org/abs/1403.3996v1","summary":"We describe JSAI, an abstract interpreter for JavaScript. JSAI uses novel\nabstract domains to compute a reduced product of type inference, pointer\nanalysis, string analysis, integer and boolean constant propagation, and\ncontrol-flow analysis. In addition, JSAI allows for analysis control-flow\nsensitivity (i.e., context-, path-, and heap-sensitivity) to be modularly\nconfigured without requiring any changes to the analysis implementation. JSAI\nis designed to be provably sound with respect to a specific concrete semantics\nfor JavaScript, which has been extensively tested against existing\nproduction-quality JavaScript implementations.\n  We provide a comprehensive evaluation of JSAI's performance and precision\nusing an extensive benchmark suite. This benchmark suite includes real-world\nJavaScript applications, machine-generated JavaScript code via Emscripten, and\nbrowser addons. We use JSAI's configurability to evaluate a large number of\nanalysis sensitivities (some well-known, some novel) and observe some\nsurprising results. We believe that JSAI's configurability and its formal\nspecifications position it as a useful research platform to experiment on novel\nsensitivities, abstract domains, and client analyses for JavaScript.","authors":["Vineeth Kashyap","Kyle Dewey","Ethan A. Kuefner","John Wagner","Kevin Gibbons","John Sarracino","Ben Wiedermann","Ben Hardekopf"],"author":"Ben Hardekopf","pdf_url":"http://arxiv.org/pdf/1403.3996v1","title":"JSAI: Designing a Sound, Configurable, and Efficient Static Analyzer for\n  JavaScript","arxiv_comment":null}
{"_id":{"$oid":"5dd4122c715f5ae58731c337"},"id":"http://arxiv.org/abs/1602.05891v1","summary":"With the increasing usage of JavaScript in web applications, there is a great\ndemand to write JavaScript code that is reliable and maintainable. To achieve\nthese goals, classes can be emulated in the current JavaScript standard\nversion. In this paper, we propose a reengineering tool to identify such\nclass-like structures and to create an object-oriented model based on\nJavaScript source code. The tool has a parser that loads the AST (Abstract\nSyntax Tree) of a JavaScript application to model its structure. It is also\nintegrated with the Moose platform to provide powerful visualization, e.g., UML\ndiagram and Distribution Maps, and well-known metric values for software\nanalysis. We also provide some examples with real JavaScript applications to\nevaluate the tool.","authors":["Leonardo Humberto Silva","Daniel Hovadick","Marco Tulio Valente","Alexandre Bergel","Nicolas Anquetil","Anne Etien"],"author":"Anne Etien","pdf_url":"http://arxiv.org/pdf/1602.05891v1","title":"JSClassFinder: A Tool to Detect Class-like Structures in JavaScript","arxiv_comment":"VI Brazilian Conference on Software: Theory and Practice (Tools\n  Track), p. 1-8, 2015"}
{"_id":{"$oid":"5dd4122c715f5ae58731c338"},"id":"http://arxiv.org/abs/1701.07860v1","summary":"The drastic increase of JavaScript exploitation attacks has led to a strong\ninterest in developing techniques to enable malicious JavaScript analysis.\nExisting analysis tech- niques fall into two general categories: static\nanalysis and dynamic analysis. Static analysis tends to produce inaccurate\nresults (both false positive and false negative) and is vulnerable to a wide\nseries of obfuscation techniques. Thus, dynamic analysis is constantly gaining\npopularity for exposing the typical features of malicious JavaScript. However,\nexisting dynamic analysis techniques possess limitations such as limited code\ncoverage and incomplete environment setup, leaving a broad attack surface for\nevading the detection. To overcome these limitations, we present the design and\nimplementation of a novel JavaScript forced execution engine named JSForce\nwhich drives an arbitrary JavaScript snippet to execute along different paths\nwithout any input or environment setup. We evaluate JSForce using 220,587 HTML\nand 23,509 PDF real- world samples. Experimental results show that by adopting\nour forced execution engine, the malicious JavaScript detection rate can be\nsubstantially boosted by 206.29% using same detection policy without any\nnoticeable false positive increase. We also make JSForce publicly available as\nan online service and will release the source code to the security community\nupon the acceptance for publication.","authors":["Xunchao Hu","Yao Cheng","Yue Duan","Andrew Henderson","Heng Yin"],"author":"Heng Yin","pdf_url":"http://arxiv.org/pdf/1701.07860v1","title":"JSForce: A Forced Execution Engine for Malicious JavaScript Detection","arxiv_comment":"15 pages,conference"}
{"_id":{"$oid":"5dd4122c715f5ae58731c339"},"id":"http://arxiv.org/abs/1506.07813v1","summary":"Web sites routinely incorporate JavaScript programs from several sources into\na single page. These sources must be protected from one another, which requires\nrobust sandboxing. The many entry-points of sandboxes and the subtleties of\nJavaScript demand robust verification of the actual sandbox source. We use a\nnovel type system for JavaScript to encode and verify sandboxing properties.\nThe resulting verifier is lightweight and efficient, and operates on actual\nsource. We demonstrate the effectiveness of our technique by applying it to\nADsafe, which revealed several bugs and other weaknesses.","authors":["Joe Gibbs Politz","Spiridon Eliopoulos","Arjun Guha","Shriram Krishnamurthi"],"author":"Shriram Krishnamurthi","pdf_url":"http://arxiv.org/pdf/1506.07813v1","title":"ADsafety: Type-Based Verification of JavaScript Sandboxing","arxiv_comment":"in Proceedings of the USENIX Security Symposium (2011)"}
{"_id":{"$oid":"5dd4122c715f5ae58731c33a"},"id":"http://arxiv.org/abs/1510.00925v1","summary":"We reduce JavaScript to a core calculus structured as a small-step\noperational semantics. We present several peculiarities of the language and\nshow that our calculus models them. We explicate the desugaring process that\nturns JavaScript programs into ones in the core. We demonstrate faithfulness to\nJavaScript using real-world test suites. Finally, we illustrate utility by\ndefining a security property, implementing it as a type system on the core, and\nextending it to the full language.","authors":["Arjun Guha","Claudiu Saftoiu","Shriram Krishnamurthi"],"author":"Shriram Krishnamurthi","pdf_url":"http://arxiv.org/pdf/1510.00925v1","title":"The Essence of JavaScript","arxiv_comment":"European Conference on Object-Oriented Programming (ECOOP) 2010"}
{"_id":{"$oid":"5dd4122c715f5ae58731c33b"},"id":"http://arxiv.org/abs/1605.04303v6","summary":"The increasing popularity of JavaScript has led to a variety of JavaScript\nframeworks that aim to help developers to address programming tasks. However,\nthe number of JavaScript frameworks has risen rapidly to thousands of versions.\nIt is challenging for practitioners to identify the frameworks that best fit\ntheir needs and to develop new ones which fit such needs. Furthermore, there is\na lack of knowledge regarding what drives developers towards the choice. This\npaper explores the factors and actors that lead to the choice of a JavaScript\nframework. We conducted a qualitative interpretive study of semi-structured\ninterviews. We interviewed 18 decision makers regarding the JavaScript\nframework selection, up to reaching theoretical saturation. Through coding the\ninterview responses, we offer a model of desirable JavaScript framework\nadoption factors. The factors are grouped into categories that are derived via\nthe Unified Theory of Acceptance and Use of Technology. The factors are\nperformance expectancy (performance, size), effort expectancy (automatization,\nlearnability, complexity, understandability), social influence (competitor\nanalysis, collegial advice, community size, community responsiveness),\nfacilitating conditions (suitability, updates, modularity, isolation,\nextensibility), and price value. A combination of four actors, which are\ncustomer, developer, team, and team leader, leads to the choice. Our model\ncontributes to the body of knowledge related to the adoption of technology by\nsoftware engineers. As a practical implication, our model is useful for\ndecision makers when evaluating JavaScript frameworks, as well as for\ndevelopers for producing desirable frameworks.","authors":["Amantia Pano","Daniel Graziotin","Pekka Abrahamsson"],"author":"Pekka Abrahamsson","pdf_url":"http://arxiv.org/pdf/1605.04303v6","title":"Factors and actors leading to the adoption of a JavaScript framework","arxiv_comment":"34 pages, 2 figures. Minor Revisions at Empirical Software\n  Engineering journal"}
{"_id":{"$oid":"5dd414c674d9f801b3d836f9"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd414c674d9f801b3d836fa"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd414c674d9f801b3d836fb"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd414c674d9f801b3d836fc"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd414c674d9f801b3d836fd"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd414c674d9f801b3d836fe"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd414c674d9f801b3d836ff"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd414c674d9f801b3d83700"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd414c674d9f801b3d83701"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd414c674d9f801b3d83702"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83703"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83704"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83705"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83706"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83707"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83708"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd41b2e74d9f801b3d83709"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd41b2e74d9f801b3d8370a"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd41b2e74d9f801b3d8370b"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd41b2e74d9f801b3d8370c"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd41c6774d9f801b3d8370d"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5dd41c6774d9f801b3d8370e"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5dd41c6774d9f801b3d8370f"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5dd41c6774d9f801b3d83710"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5dd41c6774d9f801b3d83711"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5dd41c6774d9f801b3d83712"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5dd41c6774d9f801b3d83713"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5dd41ca774d9f801b3d83714"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5dd41ca774d9f801b3d83715"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5dd41ca774d9f801b3d83716"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5dd41ca774d9f801b3d83717"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5dd41ca774d9f801b3d83718"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5dd41ca774d9f801b3d83719"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5dd41ca774d9f801b3d8371a"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5dd41ee274d9f801b3d8371b"},"id":"http://arxiv.org/abs/1712.00461v1","summary":"The LSST software systems make extensive use of Python, with almost all of it\ninitially being developed solely in Python 2. Since LSST will be commissioned\nwhen Python 2 is end-of-lifed it is critical that we have all our code support\nPython 3 before commissioning begins. Over the past year we have made\nsignificant progress in migrating the bulk of the code from the Data Management\nsystem onto Python 3. This paper presents our migration methodology, and the\ncurrent status of the port, with our eventual aim to be running completely on\nPython 3 by early 2018. We also discuss recent modernizations to our Python\ncodebase.","authors":["Tim Jenness"],"author":"Tim Jenness","pdf_url":"http://arxiv.org/pdf/1712.00461v1","title":"Modern Python at the Large Synoptic Survey Telescope","arxiv_comment":"4 pages, presented at the Astronomical Data Analysis Software and\n  Systems (ADASS) XXVII conference, Santiago, Chile, October 2017"}
{"_id":{"$oid":"5dd41ee274d9f801b3d8371c"},"id":"http://arxiv.org/abs/1106.0868v1","summary":"We create a Python GUI scripting interface working under Windows in addition\nto (UNIX/Linux). The GUI has been built around the Python open-source\nprogramming language. We use the Python's GUI library that so called Python\nMega Widgets (PMW) and based on Tkinter Python module\n(http://www.freenetpages.co.uk/hp/alan.gauld/tutgui.htm). The new GUI was\nmotivated primarily by the desire of more updated operations, more flexibility\nincorporating future and current improvements in producing atomic data.\nFurthermore it will be useful for a variety of applications of atomic physics,\nplasma physics and astrophysics and will help in calculating various atomic\nproperties.","authors":["Amani Tahat","Mofleh Tahat"],"author":"Mofleh Tahat","pdf_url":"http://arxiv.org/pdf/1106.0868v1","title":"Python GUI Scripting Interface for Running Atomic Physics Applications","arxiv_comment":"7 pages, 2 figures"}
{"_id":{"$oid":"5dd41ee274d9f801b3d8371d"},"id":"http://arxiv.org/abs/1611.00751v1","summary":"The LSST data management science pipelines software consists of more than\n100,000 lines of Python 2 code. LSST operations will begin after support for\nPython 2 has been dropped by the Python community in 2020, and we must\ntherefore plan to migrate the codebase to Python 3. During the transition\nperiod we must also support our community of active Python 2 users and this\ncomplicates the porting significantly. We have decided to use the Python future\npackage as the basis for our port to enable support for Python 2 and Python 3\nsimultaneously, whilst developing with a mindset more suited to Python 3. In\nthis paper we report on the current status of the port and the difficulties\nthat have been encountered.","authors":["Tim Jenness"],"author":"Tim Jenness","pdf_url":"http://arxiv.org/pdf/1611.00751v1","title":"Porting the LSST Data Management Pipeline Software to Python 3","arxiv_comment":"4 pages, presented at Astronomical Data Analysis Software and Systems\n  XXVI conference, Trieste, Italy, October 2016"}
{"_id":{"$oid":"5dd41ee274d9f801b3d8371e"},"id":"http://arxiv.org/abs/1010.5890v1","summary":"Python implementation of Algorithm X by Knuth is presented. Algorithm X finds\nall solutions to the exact cover problem. The exemplary results for\npentominoes, Latin squares and Sudoku are given.","authors":["Andrzej Kapanowski"],"author":"Andrzej Kapanowski","pdf_url":"http://arxiv.org/pdf/1010.5890v1","title":"Python for education: the exact cover problem","arxiv_comment":"13 pages, 4 figures, 3 tables"}
{"_id":{"$oid":"5dd41ee274d9f801b3d8371f"},"id":"http://arxiv.org/abs/1911.00648v1","summary":"One of the most attractive features of R is its linear modeling capabilities.\nWe describe a Python package, salmon, that brings the best of R's linear\nmodeling functionality to Python in a Pythonic way---by providing composable\nobjects for specifying and fitting linear models. This object-oriented design\nalso enables other features that enhance ease-of-use, such as automatic\nvisualizations and intelligent model building.","authors":["Alex Boyd","Dennis L. Sun"],"author":"Dennis L. Sun","pdf_url":"http://arxiv.org/pdf/1911.00648v1","title":"salmon: A Symbolic Linear Regression Package for Python","arxiv_comment":null}
{"_id":{"$oid":"5dd41ee274d9f801b3d83720"},"id":"http://arxiv.org/abs/0911.1633v1","summary":"pydelay is a python library which translates a system of delay differential\nequations into C-code and simulates the code using scipy weave.","authors":["V. Flunkert","E. Schoell"],"author":"E. Schoell","pdf_url":"http://arxiv.org/pdf/0911.1633v1","title":"Pydelay - a python tool for solving delay differential equations","arxiv_comment":null}
{"_id":{"$oid":"5dd41ee274d9f801b3d83721"},"id":"http://arxiv.org/abs/1404.6388v2","summary":"The Python library FatGHol FatGHoL used in Murri2012 to reckon the rational\nhomology of the moduli space of Riemann surfaces is an example of a non-numeric\nscientific code: most of the processing it does is generating graphs\n(represented by complex Python objects) and computing their isomorphisms (a\ntriple of Python lists; again a nested data structure). These operations are\nrepeated many times over: for example, the spaces and are triangulated by\n4'583'322 and 747'664 graphs, respectively. This is an opportunity for every\nPython runtime to prove its strength in optimization. The purpose of this\nexperiment was to assess the maturity of alternative Python runtimes, in terms\nof: compatibility with the language as implemented in CPython 2.7, and\nperformance speedup. This paper compares the results and experiences from\nrunning FatGHol with different Python runtimes: CPython 2.7.5, PyPy 2.1, Cython\n0.19, Numba 0.11, Nuitka 0.4.4 and Falcon.","authors":["Riccardo Murri"],"author":"Riccardo Murri","pdf_url":"http://arxiv.org/pdf/1404.6388v2","title":"Performance of Python runtimes on a non-numeric scientific code","arxiv_comment":"Part of the Proceedings of the 6th European Conference on Python in\n  Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)"}
{"_id":{"$oid":"5dd41ee274d9f801b3d83722"},"id":"http://arxiv.org/abs/1306.6047v2","summary":"Python is a popular dynamic language with a large part of its appeal coming\nfrom powerful libraries and extension modules. These augment the language and\nmake it a productive environment for a wide variety of tasks, ranging from web\ndevelopment (Django) to numerical analysis (NumPy). Unfortunately, Python's\nperformance is quite poor when compared to modern implementations of languages\nsuch as Lua and JavaScript.\n  Why does Python lag so far behind these other languages? As we show, the very\nsame API and extension libraries that make Python a powerful language also make\nit very difficult to efficiently execute. Given that we want to retain access\nto the great extension libraries that already exist for Python, how fast can we\nmake it?\n  To evaluate this, we designed and implemented Falcon, a high-performance\nbytecode interpreter fully compatible with the standard CPython interpreter.\nFalcon applies a number of well known optimizations and introduces several new\ntechniques to speed up execution of Python bytecode. In our evaluation, we\nfound Falcon an average of 25% faster than the standard Python interpreter on\nmost benchmarks and in some cases about 2.5X faster.","authors":["Russell Power","Alex Rubinsteyn"],"author":"Alex Rubinsteyn","pdf_url":"http://arxiv.org/pdf/1306.6047v2","title":"How fast can we make interpreted Python?","arxiv_comment":"Tech Report"}
{"_id":{"$oid":"5dd41ee274d9f801b3d83723"},"id":"http://arxiv.org/abs/1511.07261v1","summary":"We present a Python extension to the massively parallel HPC simulation\ntoolkit waLBerla. waLBerla is a framework for stencil based algorithms\noperating on block-structured grids, with the main application field being\nfluid simulations in complex geometries using the lattice Boltzmann method.\nCareful performance engineering results in excellent node performance and good\nscalability to over 400,000 cores. To increase the usability and flexibility of\nthe framework, a Python interface was developed. Python extensions are used at\nall stages of the simulation pipeline: They simplify and automate scenario\nsetup, evaluation, and plotting. We show how our Python interface outperforms\nthe existing text-file-based configuration mechanism, providing features like\nautomatic nondimensionalization of physical quantities and handling of complex\nparameter dependencies. Furthermore, Python is used to process and evaluate\nresults while the simulation is running, leading to smaller output files and\nthe possibility to adjust parameters dependent on the current simulation state.\nC++ data structures are exported such that a seamless interfacing to other\nnumerical Python libraries is possible. The expressive power of Python and the\nperformance of C++ make development of efficient code with low time effort\npossible.","authors":["Martin Bauer","Florian Schornbaum","Christian Godenschwager","Matthias Markl","Daniela Anderl","Harald K√∂stler","Ulrich R√ºde"],"author":"Ulrich R√ºde","pdf_url":"http://arxiv.org/pdf/1511.07261v1","title":"A Python Extension for the Massively Parallel Multiphysics Simulation\n  Framework waLBerla","arxiv_comment":null}
{"_id":{"$oid":"5dd41ee274d9f801b3d83724"},"id":"http://arxiv.org/abs/1802.06224v1","summary":"Object-Z is an object-oriented specification language which extends the Z\nlanguage with classes, objects, inheritance and polymorphism that can be used\nto represent the specification of a complex system as collections of objects.\nThere are a number of existing works that mapped Object-Z to C++ and Java\nprogramming languages. Since Python and Object-Z share many similarities, both\nare object-oriented paradigm, support set theory and predicate calculus\nmoreover, Python is a functional programming language which is naturally closer\nto formal specifications, we propose a mapping from Object-Z specifications to\nPython code that covers some Object-Z constructs and express its specifications\nin Python to validate these specifications. The validations are used in the\nmapping covered preconditions, post-conditions, and invariants that are built\nusing lambda function and Python's decorator. This work has found Python is an\nexcellent language for developing libraries to map Object-Z specifications to\nPython.","authors":["A. F. Al Azzawi","M. Bettaz","H. M. Al-Refai"],"author":"H. M. Al-Refai","pdf_url":"http://arxiv.org/pdf/1802.06224v1","title":"Generating Python Code From Object-Z Specifications","arxiv_comment":"12 pages, 3 figures"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d83725"},"id":"http://arxiv.org/abs/1712.00461v1","summary":"The LSST software systems make extensive use of Python, with almost all of it\ninitially being developed solely in Python 2. Since LSST will be commissioned\nwhen Python 2 is end-of-lifed it is critical that we have all our code support\nPython 3 before commissioning begins. Over the past year we have made\nsignificant progress in migrating the bulk of the code from the Data Management\nsystem onto Python 3. This paper presents our migration methodology, and the\ncurrent status of the port, with our eventual aim to be running completely on\nPython 3 by early 2018. We also discuss recent modernizations to our Python\ncodebase.","authors":["Tim Jenness"],"author":"Tim Jenness","pdf_url":"http://arxiv.org/pdf/1712.00461v1","title":"Modern Python at the Large Synoptic Survey Telescope","arxiv_comment":"4 pages, presented at the Astronomical Data Analysis Software and\n  Systems (ADASS) XXVII conference, Santiago, Chile, October 2017"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d83726"},"id":"http://arxiv.org/abs/1106.0868v1","summary":"We create a Python GUI scripting interface working under Windows in addition\nto (UNIX/Linux). The GUI has been built around the Python open-source\nprogramming language. We use the Python's GUI library that so called Python\nMega Widgets (PMW) and based on Tkinter Python module\n(http://www.freenetpages.co.uk/hp/alan.gauld/tutgui.htm). The new GUI was\nmotivated primarily by the desire of more updated operations, more flexibility\nincorporating future and current improvements in producing atomic data.\nFurthermore it will be useful for a variety of applications of atomic physics,\nplasma physics and astrophysics and will help in calculating various atomic\nproperties.","authors":["Amani Tahat","Mofleh Tahat"],"author":"Mofleh Tahat","pdf_url":"http://arxiv.org/pdf/1106.0868v1","title":"Python GUI Scripting Interface for Running Atomic Physics Applications","arxiv_comment":"7 pages, 2 figures"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d83727"},"id":"http://arxiv.org/abs/1611.00751v1","summary":"The LSST data management science pipelines software consists of more than\n100,000 lines of Python 2 code. LSST operations will begin after support for\nPython 2 has been dropped by the Python community in 2020, and we must\ntherefore plan to migrate the codebase to Python 3. During the transition\nperiod we must also support our community of active Python 2 users and this\ncomplicates the porting significantly. We have decided to use the Python future\npackage as the basis for our port to enable support for Python 2 and Python 3\nsimultaneously, whilst developing with a mindset more suited to Python 3. In\nthis paper we report on the current status of the port and the difficulties\nthat have been encountered.","authors":["Tim Jenness"],"author":"Tim Jenness","pdf_url":"http://arxiv.org/pdf/1611.00751v1","title":"Porting the LSST Data Management Pipeline Software to Python 3","arxiv_comment":"4 pages, presented at Astronomical Data Analysis Software and Systems\n  XXVI conference, Trieste, Italy, October 2016"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d83728"},"id":"http://arxiv.org/abs/1010.5890v1","summary":"Python implementation of Algorithm X by Knuth is presented. Algorithm X finds\nall solutions to the exact cover problem. The exemplary results for\npentominoes, Latin squares and Sudoku are given.","authors":["Andrzej Kapanowski"],"author":"Andrzej Kapanowski","pdf_url":"http://arxiv.org/pdf/1010.5890v1","title":"Python for education: the exact cover problem","arxiv_comment":"13 pages, 4 figures, 3 tables"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d83729"},"id":"http://arxiv.org/abs/1911.00648v1","summary":"One of the most attractive features of R is its linear modeling capabilities.\nWe describe a Python package, salmon, that brings the best of R's linear\nmodeling functionality to Python in a Pythonic way---by providing composable\nobjects for specifying and fitting linear models. This object-oriented design\nalso enables other features that enhance ease-of-use, such as automatic\nvisualizations and intelligent model building.","authors":["Alex Boyd","Dennis L. Sun"],"author":"Dennis L. Sun","pdf_url":"http://arxiv.org/pdf/1911.00648v1","title":"salmon: A Symbolic Linear Regression Package for Python","arxiv_comment":null}
{"_id":{"$oid":"5dd41f2a74d9f801b3d8372a"},"id":"http://arxiv.org/abs/0911.1633v1","summary":"pydelay is a python library which translates a system of delay differential\nequations into C-code and simulates the code using scipy weave.","authors":["V. Flunkert","E. Schoell"],"author":"E. Schoell","pdf_url":"http://arxiv.org/pdf/0911.1633v1","title":"Pydelay - a python tool for solving delay differential equations","arxiv_comment":null}
{"_id":{"$oid":"5dd41f2a74d9f801b3d8372b"},"id":"http://arxiv.org/abs/1404.6388v2","summary":"The Python library FatGHol FatGHoL used in Murri2012 to reckon the rational\nhomology of the moduli space of Riemann surfaces is an example of a non-numeric\nscientific code: most of the processing it does is generating graphs\n(represented by complex Python objects) and computing their isomorphisms (a\ntriple of Python lists; again a nested data structure). These operations are\nrepeated many times over: for example, the spaces and are triangulated by\n4'583'322 and 747'664 graphs, respectively. This is an opportunity for every\nPython runtime to prove its strength in optimization. The purpose of this\nexperiment was to assess the maturity of alternative Python runtimes, in terms\nof: compatibility with the language as implemented in CPython 2.7, and\nperformance speedup. This paper compares the results and experiences from\nrunning FatGHol with different Python runtimes: CPython 2.7.5, PyPy 2.1, Cython\n0.19, Numba 0.11, Nuitka 0.4.4 and Falcon.","authors":["Riccardo Murri"],"author":"Riccardo Murri","pdf_url":"http://arxiv.org/pdf/1404.6388v2","title":"Performance of Python runtimes on a non-numeric scientific code","arxiv_comment":"Part of the Proceedings of the 6th European Conference on Python in\n  Science (EuroSciPy 2013), Pierre de Buyl and Nelle Varoquaux editors, (2014)"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d8372c"},"id":"http://arxiv.org/abs/1306.6047v2","summary":"Python is a popular dynamic language with a large part of its appeal coming\nfrom powerful libraries and extension modules. These augment the language and\nmake it a productive environment for a wide variety of tasks, ranging from web\ndevelopment (Django) to numerical analysis (NumPy). Unfortunately, Python's\nperformance is quite poor when compared to modern implementations of languages\nsuch as Lua and JavaScript.\n  Why does Python lag so far behind these other languages? As we show, the very\nsame API and extension libraries that make Python a powerful language also make\nit very difficult to efficiently execute. Given that we want to retain access\nto the great extension libraries that already exist for Python, how fast can we\nmake it?\n  To evaluate this, we designed and implemented Falcon, a high-performance\nbytecode interpreter fully compatible with the standard CPython interpreter.\nFalcon applies a number of well known optimizations and introduces several new\ntechniques to speed up execution of Python bytecode. In our evaluation, we\nfound Falcon an average of 25% faster than the standard Python interpreter on\nmost benchmarks and in some cases about 2.5X faster.","authors":["Russell Power","Alex Rubinsteyn"],"author":"Alex Rubinsteyn","pdf_url":"http://arxiv.org/pdf/1306.6047v2","title":"How fast can we make interpreted Python?","arxiv_comment":"Tech Report"}
{"_id":{"$oid":"5dd41f2a74d9f801b3d8372d"},"id":"http://arxiv.org/abs/1511.07261v1","summary":"We present a Python extension to the massively parallel HPC simulation\ntoolkit waLBerla. waLBerla is a framework for stencil based algorithms\noperating on block-structured grids, with the main application field being\nfluid simulations in complex geometries using the lattice Boltzmann method.\nCareful performance engineering results in excellent node performance and good\nscalability to over 400,000 cores. To increase the usability and flexibility of\nthe framework, a Python interface was developed. Python extensions are used at\nall stages of the simulation pipeline: They simplify and automate scenario\nsetup, evaluation, and plotting. We show how our Python interface outperforms\nthe existing text-file-based configuration mechanism, providing features like\nautomatic nondimensionalization of physical quantities and handling of complex\nparameter dependencies. Furthermore, Python is used to process and evaluate\nresults while the simulation is running, leading to smaller output files and\nthe possibility to adjust parameters dependent on the current simulation state.\nC++ data structures are exported such that a seamless interfacing to other\nnumerical Python libraries is possible. The expressive power of Python and the\nperformance of C++ make development of efficient code with low time effort\npossible.","authors":["Martin Bauer","Florian Schornbaum","Christian Godenschwager","Matthias Markl","Daniela Anderl","Harald K√∂stler","Ulrich R√ºde"],"author":"Ulrich R√ºde","pdf_url":"http://arxiv.org/pdf/1511.07261v1","title":"A Python Extension for the Massively Parallel Multiphysics Simulation\n  Framework waLBerla","arxiv_comment":null}
{"_id":{"$oid":"5dd41f2b74d9f801b3d8372e"},"id":"http://arxiv.org/abs/1802.06224v1","summary":"Object-Z is an object-oriented specification language which extends the Z\nlanguage with classes, objects, inheritance and polymorphism that can be used\nto represent the specification of a complex system as collections of objects.\nThere are a number of existing works that mapped Object-Z to C++ and Java\nprogramming languages. Since Python and Object-Z share many similarities, both\nare object-oriented paradigm, support set theory and predicate calculus\nmoreover, Python is a functional programming language which is naturally closer\nto formal specifications, we propose a mapping from Object-Z specifications to\nPython code that covers some Object-Z constructs and express its specifications\nin Python to validate these specifications. The validations are used in the\nmapping covered preconditions, post-conditions, and invariants that are built\nusing lambda function and Python's decorator. This work has found Python is an\nexcellent language for developing libraries to map Object-Z specifications to\nPython.","authors":["A. F. Al Azzawi","M. Bettaz","H. M. Al-Refai"],"author":"H. M. Al-Refai","pdf_url":"http://arxiv.org/pdf/1802.06224v1","title":"Generating Python Code From Object-Z Specifications","arxiv_comment":"12 pages, 3 figures"}
{"_id":{"$oid":"5dd41f4474d9f801b3d8372f"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd41f4474d9f801b3d83730"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd41f4474d9f801b3d83731"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd41f4474d9f801b3d83732"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd41f4474d9f801b3d83733"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd41f4474d9f801b3d83734"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd41f4474d9f801b3d83735"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd41f4474d9f801b3d83736"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd41f4474d9f801b3d83737"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd41f4474d9f801b3d83738"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd41f6074d9f801b3d83739"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373a"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373b"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373c"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373d"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373e"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd41f6074d9f801b3d8373f"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd41f6074d9f801b3d83740"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd41f6074d9f801b3d83741"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd41f6074d9f801b3d83742"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5dd41faa74d9f801b3d83743"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5dd41faa74d9f801b3d83744"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5dd41faa74d9f801b3d83745"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5dd41faa74d9f801b3d83746"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5dd41faa74d9f801b3d83747"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5dd41faa74d9f801b3d83748"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5dd41faa74d9f801b3d83749"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5dd41faa74d9f801b3d8374a"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5dd41faa74d9f801b3d8374b"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5dd41faa74d9f801b3d8374c"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5ddd40aef72158257a071e02"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5ddd40aef72158257a071e03"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5ddd40aef72158257a071e04"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5ddd40aef72158257a071e05"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5ddd40aef72158257a071e06"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5ddd40aef72158257a071e07"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5ddd40aef72158257a071e08"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5ddd40aef72158257a071e09"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5ddd40aef72158257a071e0a"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5ddd40aef72158257a071e0b"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
{"_id":{"$oid":"5ddd43a1f72158257a071e0c"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5ddd43a1f72158257a071e0d"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5ddd43a1f72158257a071e0e"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5ddd43a1f72158257a071e0f"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5ddd43a1f72158257a071e10"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5ddd43a1f72158257a071e11"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5ddd43a1f72158257a071e12"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5ddd4ba4f72158257a071e13"},"id":"http://arxiv.org/abs/1704.07887v1","summary":"We present rootJS, an interface making it possible to seamlessly integrate\nROOT 6 into applications written for Node.js, the JavaScript runtime platform\nincreasingly commonly used to create high-performance Web applications. ROOT\nfeatures can be called both directly from Node.js code and by JIT-compiling C++\nmacros. All rootJS methods are invoked asynchronously and support callback\nfunctions, allowing non-blocking operation of Node.js applications using them.\nLast but not least, our bindings have been designed to platform-independent and\nshould therefore work on all systems supporting both ROOT 6 and Node.js.\n  Thanks to rootJS it is now possible to create ROOT-aware Web applications\ntaking full advantage of the high performance and extensive capabilities of\nNode.js. Examples include platforms for the quality assurance of acquired,\nreconstructed or simulated data, book-keeping and e-log systems, and even Web\nbrowser-based data visualisation and analysis.","authors":["Theo Beffart","Maximilian Fr√ºh","Christoph Haas","Sachin Rajgopal","Jonas Schwabe","Christoph Wolff","Marek Szuba"],"author":"Marek Szuba","pdf_url":"http://arxiv.org/pdf/1704.07887v1","title":"RootJS: Node.js Bindings for ROOT 6","arxiv_comment":"7 pages, 1 figure. To appear in the Proceedings of the 22nd\n  International Conference on Computing in High Energy and Nuclear Physics\n  (CHEP 2016)"}
{"_id":{"$oid":"5ddd4ba4f72158257a071e14"},"id":"http://arxiv.org/abs/1903.04969v1","summary":"The creation of Linked Data from raw data sources is, in theory, no rocket\nscience (pun intended). Depending on the nature of the input and the mapping\ntechnology in use, it can become a quite tedious task. For our work on mapping\nreal-life touristic data to the schema.org vocabulary we used RML but soon\nencountered, that the existing Java mapper implementations reached their limits\nand were not sufficient for our use cases. In this paper we describe a new\nimplementation of an RML mapper. Written with the JavaScript based NodeJS\nframework it performs quite well for our uses cases where we work with large\nXML and JSON files. The performance testing and the execution of the RML test\ncases have shown, that the implementation has great potential to perform heavy\nmapping tasks in reasonable time, but comes with some limitations regarding\nJOINs, Named Graphs and inputs other than XML and JSON - which is fine at the\nmoment, due to the nature of the given use cases.","authors":["Umutcan ≈ûim≈üek","Elias K√§rle","Dieter Fensel"],"author":"Dieter Fensel","pdf_url":"http://arxiv.org/pdf/1903.04969v1","title":"RocketRML - A NodeJS implementation of a use-case specific RML mapper","arxiv_comment":"8 pages, submitted to KGB Workshop 2019 at ESWC"}
{"_id":{"$oid":"5ddd4ba4f72158257a071e15"},"id":"http://arxiv.org/abs/1602.03681v1","summary":"The public package registry npm is one of the biggest software registry. With\nits 216 911 software packages, it forms a big network of software dependencies.\nIn this paper we evaluate various methods for finding similar packages in the\nnpm network, using only the structure of the graph. Namely, we want to find a\nway of categorizing similar packages, which would be useful for recommendation\nsystems. This size enables us to compute meaningful results, as it softened the\nparticularities of the graph. Npm is also quite famous as it is the default\npackage repository of Node.js. We believe that it will make our results\ninteresting for more people than a less used package repository. This makes it\na good subject of analysis of software networks.","authors":["Tomislav Slijepƒçeviƒá"],"author":"Tomislav Slijepƒçeviƒá","pdf_url":"http://arxiv.org/pdf/1602.03681v1","title":"Package equivalence in complex software network","arxiv_comment":null}
{"_id":{"$oid":"5ddd4ba4f72158257a071e16"},"id":"http://arxiv.org/abs/1909.00059v1","summary":"In this article, we present a finite time stopping criterion for consensus\nalgorithms in networks with dynamic communication topology. Recent results\nprovide asymptotic convergence to the consensus algorithm. However, the\nasymptotic convergence of these algorithms pose a challenge in the practical\nsettings where the response from agents is required in finite time. To this\nend, we propose a Maximum-Minimum protocol which propagates the global maximum\nand minimum values of agent states (while running consensus algorithm) in the\nnetwork. We establish that global maximum and minimum values are strictly\nmonotonic even for a dynamic topology and can be utilized to distributively\nascertain the closeness to convergence in finite time. We show that each node\ncan have access to the global maximum and minimum by running the proposed\nMaximum-Minimum protocol and use it as a finite time stopping criterion for the\notherwise asymptotic consensus algorithm. The practical utility of the\nalgorithm is illustrated through experiments where each agent is instantiated\nby a NodeJS socket.io server.","authors":["Govind Saraswat","Vivek Khatana","Sourav Patel","Murti V. Salapaka"],"author":"Murti V. Salapaka","pdf_url":"http://arxiv.org/pdf/1909.00059v1","title":"Distributed finite-time termination for consensus algorithm in switching\n  topologies","arxiv_comment":null}
{"_id":{"$oid":"5ddd4ba4f72158257a071e17"},"id":"http://arxiv.org/abs/1910.05779v1","summary":"Data provenance and lineage are critical for ensuring integrity and\nreproducibility of information in research and application. This is\nparticularly challenging for distributed scenarios, where data may be\noriginating from decentralized sources without any central control by a single\ntrusted entity. We present HyperProv, a general framework for data provenance\nbased on the permissioned blockchain Hyperledger Fabric (HLF), and to the best\nof our knowledge, the first system that is ported to ARM based devices such as\nRaspberry Pi (RPi). HyperProv tracks the metadata, operation history and data\nlineage through a set of built-in queries using smart contracts, enabling\nlightweight retrieval of provenance data. HyperProv provides convenient\nintegration through a NodeJS client library, and also includes off-chain\nstorage through the SSH file system. We evaluate HyperProv's performance,\nthroughput, resource consumption, and energy efficiency on x86-64 machines, as\nwell as on RPi devices for IoT use cases at the edge.","authors":["Petter Tunstad","Amin M. Khan","Phuong Hoai Ha"],"author":"Phuong Hoai Ha","pdf_url":"http://arxiv.org/pdf/1910.05779v1","title":"HyperProv: Decentralized Resilient Data Provenance at the Edge with\n  Blockchains","arxiv_comment":null}
{"_id":{"$oid":"5ddd4ba4f72158257a071e18"},"id":"http://arxiv.org/abs/1510.00216v1","summary":"Background: The Virtual Rehabilitation Environment (VRE) provides patients of\nlong term neurological conditions with a platform to review their previous\nphysiotherapy sessions, as well as see their goals and any treatments or\nexercises that their clinician has set for them to practice before their next\nsession.\n  Objective: The initial application implemented 21 of the 27 core features\nusing the Microsoft ASP.NET MVC stack. However, the two core, non-functional\nrequirements were negated from the project due to lack of experience and strict\ntime constraints. This project aimed to investigate whether the application\nwould be more suited to a non-relational solution.\n  Method: The application was re-written using the MEAN stack (MongoDB,\nExpressJS, AngularJS, NodeJS), an open source, fully JavaScript stack and then\nperformance tests were carried out to compare the two applications. A\nscalability review was also conducted to assess the benefits and drawbacks of\neach technology in this aspect.\n  Results: The investigation proved that the non-relational solution was much\nmore efficient and performed faster. However, the choice of database was only a\nsmall part of the increase in efficiency and it was an all-round better design\nthat gave the new application its performance upper hand.\n  Conclusion: A proposal for a new application design is given that follows the\nmicroservice architecture used by companies such as Amazon and Netflix. The\napplication is to be split up into four parts; database, client application,\nserver application and content delivery network. These four, independently\nscalable and manageable services offer the greatest flexibility for future\ndevelopment at the low costs necessary for a start-up.","authors":["Ashley Williams"],"author":"Ashley Williams","pdf_url":"http://arxiv.org/pdf/1510.00216v1","title":"A comparison of the performance and scalability of relational and\n  document-based web-systems for large scale applications in a rehabilitation\n  context","arxiv_comment":"Unpublished MSc thesis"}
{"_id":{"$oid":"5ddd4ba4f72158257a071e19"},"id":"http://arxiv.org/abs/1802.01790v1","summary":"In the last years Node.js has emerged as a framework particularly suitable\nfor implementing lightweight IoT applications, thanks to its underlying\nasynchronous event-driven, non blocking I/O model. However, verifying the\ncorrectness of programs with asynchronous nested callbacks is quite difficult,\nand, hence, runtime monitoring can be a valuable support to tackle such a\ncomplex task.\n  Runtime monitoring is a useful software verification technique that\ncomplements static analysis and testing, but has not been yet fully explored in\nthe context of Internet of Things (IoT) systems. Trace expressions have been\nsuccessfully employed for runtime monitoring in widespread multiagent system\nplatforms. Recently, their expressive power has been extended to allow\nparametric specifications on data that can be captured and monitored only at\nruntime. Furthermore, they can be language and system agnostic, through the\nnotion of event domain and type. This paper investigates the use of parametric\ntrace expressions as a first step towards runtime monitoring of programs\ndeveloped in Node.js and Node-RED, a flow-based IoT programming tool built on\ntop of Node.js. Runtime verification of such systems is a task that mostly\nseems to have been overlooked so far in the literature.\n  A prototype implementing the proposed system for Node.js, in order to\ndynamically check with trace expressions the correct usage of API functions, is\npresented. The tool exploits the dynamic analysis framework Jalangi for\nmonitoring Node.js programs and allows detection of errors that would be\ndifficult to catch with other techniques. Furthermore, it offers a simple REST\ninterface which can be exploited for runtime verification of Node-RED\ncomponents, and, more generally, IoT devices.","authors":["Davide Ancona","Luca Franceschini","Giorgio Delzanno","Maurizio Leotta","Marina Ribaudo","Filippo Ricca"],"author":"Filippo Ricca","pdf_url":"http://arxiv.org/pdf/1802.01790v1","title":"Towards Runtime Monitoring of Node.js and Its Application to the\n  Internet of Things","arxiv_comment":"In Proceedings ALP4IoT 2017, arXiv:1802.00976"}
{"_id":{"$oid":"5ddd4f23f72158257a071e1a"},"id":"http://arxiv.org/abs/1810.04308v1","summary":"AIJ (ACL2 In Java) is a deep embedding in Java of an executable,\nside-effect-free, non-stobj-accessing subset of the ACL2 language without\nguards. ATJ (ACL2 To Java) is a simple Java code generator that turns ACL2\nfunctions into AIJ representations that are evaluated by the AIJ interpreter.\nAIJ and ATJ enable possibly verified ACL2 code to run as, and interoperate\nwith, Java code, without much of the ACL2 framework or any of the Lisp runtime.\nThe current speed of the resulting Java code may be adequate to some\napplications.","authors":["Alessandro Coglio"],"author":"Alessandro Coglio","pdf_url":"http://arxiv.org/pdf/1810.04308v1","title":"A Simple Java Code Generator for ACL2 Based on a Deep Embedding of ACL2\n  in Java","arxiv_comment":"In Proceedings ACL2 2018, arXiv:1810.03762"}
{"_id":{"$oid":"5ddd4f23f72158257a071e1b"},"id":"http://arxiv.org/abs/1110.3379v1","summary":"Recently Java programming environment has become so popular. Java programming\nlanguage is a language that is designed to be portable enough to be executed in\nwide range of computers ranging from cell phones to supercomputers. Computer\nprograms written in Java are compiled into Java Byte code instructions that are\nsuitable for execution by a Java Virtual Machine implementation. Java virtual\nMachine is commonly implemented in software by means of an interpreter for the\nJava Virtual Machine instruction set. As an object oriented language, Java\nutilizes the concept of objects. Our idea is to identify the candidate objects'\nreferences in a Java environment through hierarchical cluster analysis using\nreference stack and execution stack.","authors":["Rahul Saha","Dr. G. Geetha"],"author":"Dr. G. Geetha","pdf_url":"http://arxiv.org/pdf/1110.3379v1","title":"Identifying Reference Objects by Hierarchical Clustering in Java\n  Environment","arxiv_comment":"8 pages,13 tables,2 figures"}
{"_id":{"$oid":"5ddd4f23f72158257a071e1c"},"id":"http://arxiv.org/abs/1608.08970v1","summary":"We describe a graph visualization tool for visualizing Java bytecode. Our\ntool, which we call J-Viz, visualizes connected directed graphs according to a\ncanonical node ordering, which we call the sibling-first recursive (SFR)\nnumbering. The particular graphs we consider are derived from applying Shiver's\nk-CFA framework to Java bytecode, and our visualizer includes helpful links\nbetween the nodes of an input graph and the Java bytecode that produced it, as\nwell as a decompiled version of that Java bytecode. We show through several\ncase studies that the canonical drawing paradigm used in J-Viz is effective for\nidentifying potential security vulnerabilities and repeated use of the same\ncode in Java applications.","authors":["Md. Jawaherul Alam","Michael T. Goodrich","Timothy Johnson"],"author":"Timothy Johnson","pdf_url":"http://arxiv.org/pdf/1608.08970v1","title":"J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java\n  Bytecode","arxiv_comment":null}
{"_id":{"$oid":"5ddd4f23f72158257a071e1d"},"id":"http://arxiv.org/abs/1709.02823v1","summary":"On the one side, network simulation frameworks are important tools for\nresearch and development activities to evaluate novel approaches in a time- and\ncost-efficient way. On the other side, Java as a highly platform-independent\nprogramming language is ideally suited for rapid prototyping in heterogeneous\nscenarios. Consequently, Java simulation frameworks could be used to firstly\nperform functional verification of new approaches (and protocols) in a\nsimulation environment and afterwards, to evaluate these approaches in real\ntestbeds using prototype Java implementations. Finally, the simulation models\ncan be refined using real world measurement data. Unfortunately, there is to\nthe best of our knowledge no satisfying Java framework for network simulation,\nas the OMNeT++ Java support ended with OMNeT++ version 4.6. Hence, our\ncontributions are as follows: we present Java extensions for OMNeT++ 5.0 that\nenable the execution of Java simulation models and give a detailed explanation\nof the working principles of the OMNeT++ Java extensions that are based on Java\nNative Interface. We conduct several case studies to evaluate the concept of\nJava extensions for OMNeT++. Most importantly, we show that the combined use of\nJava simulation models and C++ models (e.g., from the INET framework) is\npossible.","authors":["Henning Puttnies","Peter Danielis","Christian Koch","Dirk Timmermann"],"author":"Dirk Timmermann","pdf_url":"http://arxiv.org/pdf/1709.02823v1","title":"Java Extensions for OMNeT++","arxiv_comment":"Published in: A. Foerster, A. Udugama, A. Koensgen, A. Virdis, M.\n  Kirsche (Eds.), Proc. of the 4th OMNeT++ Community Summit, University of\n  Bremen - Germany - September 7-8, 2017"}
{"_id":{"$oid":"5ddd4f23f72158257a071e1e"},"id":"http://arxiv.org/abs/1605.05274v2","summary":"This paper describes a reduction from the halting problem of Turing machines\nto subtype checking in Java. It follows that subtype checking in Java is\nundecidable, which answers a question posed by Kennedy and Pierce in 2007. It\nalso follows that Java's type checker can recognize any recursive language,\nwhich improves a result of Gil and Levy from 2016. The latter point is\nillustrated by a parser generator for fluent interfaces.","authors":["Radu Grigore"],"author":"Radu Grigore","pdf_url":"http://arxiv.org/pdf/1605.05274v2","title":"Java Generics are Turing Complete","arxiv_comment":"POPL2017"}
{"_id":{"$oid":"5ddd4f23f72158257a071e1f"},"id":"http://arxiv.org/abs/1607.00825v1","summary":"Jython is a Java-based Python implementation and the most seamless way to\nintegrate Python and Java. It achieves high efficiency by compiling Python code\nto Java bytecode and thus letting Java's JIT optimize it - an approach that\nenables Python code to call Java functions or to subclass Java classes. It\nenables Python code to leverage Java's multithreading features and utilizes\nJava's built-in garbage collection (GC). However, it currently does not support\nCPython's C-API and thus does not support native extensions like NumPy and\nSciPy. Since most scientific code depends on such extensions, it is not\nrunnable with Jython. Jython Native Interface (JyNI) is a compatibility layer\nthat aims to provide CPython's native C extension API on top of Jython. JyNI is\nimplemented using the Java Native Interface (JNI) and its native part is\ndesigned to be binary compatible with existing extension builds [...].","authors":["Stefan Richthofer"],"author":"Stefan Richthofer","pdf_url":"http://arxiv.org/pdf/1607.00825v1","title":"Garbage Collection in JyNI - How to bridge Mark/Sweep and Reference\n  Counting GC","arxiv_comment":null}
{"_id":{"$oid":"5ddd4f23f72158257a071e20"},"id":"http://arxiv.org/abs/1710.09968v1","summary":"Fast, byte-addressable non-volatile memory (NVM) embraces both near-DRAM\nlatency and disk-like persistence, which has generated considerable interests\nto revolutionize system software stack and programming models. However, it is\nless understood how NVM can be combined with managed runtime like Java virtual\nmachine (JVM) to ease persistence management. This paper proposes Espresso, a\nholistic extension to Java and its runtime, to enable Java programmers to\nexploit NVM for persistence management with high performance. Espresso first\nprovides a general persistent heap design called Persistent Java Heap (PJH) to\nmanage persistent data as normal Java objects. The heap is then strengthened\nwith a recoverable mechanism to provide crash consistency for heap metadata. It\nthen provides a new abstraction called Persistent Java Object (PJO) to provide\nan easy-to-use but safe persistent programming model for programmers to persist\napplication data. The evaluation confirms that Espresso significantly\noutperforms state-of-art NVM support for Java (i.e., JPA and PCJ) while being\ncompatible to existing data structures in Java programs.","authors":["Mingyu Wu","Ziming Zhao","Haoyu Li","Heting Li","Haibo Chen","Binyu Zang","Haibing Guan"],"author":"Haibing Guan","pdf_url":"http://arxiv.org/pdf/1710.09968v1","title":"Espresso: Brewing Java For More Non-Volatility with Non-volatile Memory","arxiv_comment":null}
{"_id":{"$oid":"5ddd4f23f72158257a071e21"},"id":"http://arxiv.org/abs/1108.0355v1","summary":"In recent years Java has matured to a stable easy-to-use language with the\nflexibility of an interpreter (for reflection etc.) but the performance and\ntype checking of a compiled language. When we started using Java for\nastronomical applications around 1999 they were the first of their kind in\nastronomy. Now a great deal of astronomy software is written in Java as are\nmany business applications.\n  We discuss the current environment and trends concerning the language and\npresent an actual example of scientific use of Java for high-performance\ndistributed computing: ESA's mission Gaia. The Gaia scanning satellite will\nperform a galactic census of about 1000 million objects in our galaxy. The Gaia\ncommunity has chosen to write its processing software in Java. We explore the\nmanifold reasons for choosing Java for this large science collaboration.\n  Gaia processing is numerically complex but highly distributable, some parts\nbeing embarrassingly parallel. We describe the Gaia processing architecture and\nits realisation in Java. We delve into the astrometric solution which is the\nmost advanced and most complex part of the processing. The Gaia simulator is\nalso written in Java and is the most mature code in the system. This has been\nsuccessfully running since about 2005 on the supercomputer \"Marenostrum\" in\nBarcelona. We relate experiences of using Java on a large shared machine.\n  Finally we discuss Java, including some of its problems, for scientific\ncomputing.","authors":["William O'Mullane","Xavier Luri","Paul Parsons","Uwe Lammers","John Hoar","Jose Hernandez"],"author":"Jose Hernandez","pdf_url":"http://arxiv.org/pdf/1108.0355v1","title":"Using Java for distributed computing in the Gaia satellite data\n  processing","arxiv_comment":"Experimental Astronomy, August 2011"}
{"_id":{"$oid":"5ddd4f23f72158257a071e22"},"id":"http://arxiv.org/abs/1306.5507v1","summary":"Smart cards are widely used along with PayTV receivers to store secret user\nkeys and to perform security functions to prevent any unauthorized viewing of\nPayTV channels. Java Card technology enables programs written in the Java\nprogramming language to run on smart cards. Smart cards represent one of the\nsmallest computing platforms in use today. The memory configuration of a smart\ncard are of the order of 4K of RAM, 72K of EEPROM, and 24K of ROM. Using Java\ncard provides advantages to the industry in terms of ease of coding, faster\ntime to market and faster upgrades as compared to plain smart cards . Also\ndifferent applications like payTV, e-commerce, health-card can easily be\nimplemented in a single java card as multiple applets corresponding to each\napplication can coexists in a single java card. But there are security concerns\nin java cards and also the performance issues. In this paper, we analyse the\nsuitability of using Java card for PayTV applications as part of conditional\naccess system in place of plain smart cards.","authors":["Pallab Dutta"],"author":"Pallab Dutta","pdf_url":"http://arxiv.org/pdf/1306.5507v1","title":"Java Card for PayTv Application","arxiv_comment":null}
{"_id":{"$oid":"5ddd4f23f72158257a071e23"},"id":"http://arxiv.org/abs/1804.07271v1","summary":"This technical report describes the implementation of a lazy functional\nprogramming language on the Java VM.","authors":["Tony Clark"],"author":"Tony Clark","pdf_url":"http://arxiv.org/pdf/1804.07271v1","title":"EBG: A Lazy Functional Programming Language Implemented on the Java\n  Virtual Machine","arxiv_comment":null}
